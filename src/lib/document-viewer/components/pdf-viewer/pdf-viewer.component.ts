import {
  AfterViewInit,
  Component,
  ElementRef,
  EventEmitter,
  HostListener,
  Input,
  Output,
  QueryList,
  ViewChildren,
  NgZone,
} from '@angular/core';
import { UntilDestroy, untilDestroyed } from '@ngneat/until-destroy';
import { createArray, required, waitAnimationFrame } from '@traent/ts-utils';
import equal from 'fast-deep-equal';
import { PDFDocumentProxy, PDFPageProxy, TextContent } from 'pdfjs-dist/types/display/api';
import { BehaviorSubject, Observable, Subject, combineLatest } from 'rxjs';
import { map, switchMap, startWith, debounceTime, distinctUntilChanged } from 'rxjs/operators';

import { PageRect, PdfAnchor, SelectionRangeInfo, AcrofieldPdfAnchorV1 } from '../../models/pdf-anchor';
import { isAnnotationSupported } from '../../utils/acrofield';
import { getCurrentPage, getPages, scrollToPage } from '../../utils/pdf';
import { getAnchorFromAnnotation, getAnchorFromSelection, getSelectionCaret, pointerToAnchor } from '../../utils/pdf-anchor';

export interface AcrofieldClickEvent {
  mouseEvent: MouseEvent;
  anchor: AcrofieldPdfAnchorV1;
}

@Component({
  selector: 'ngx-t3-pdf-viewer',
  templateUrl: './pdf-viewer.component.html',
  styleUrls: ['./pdf-viewer.component.scss'],
})
@UntilDestroy()
export class PdfViewerComponent implements AfterViewInit {
  // Public APIs
  @Input() data: PDFDocumentProxy | null = null;

  private readonly zoomChange$ = new BehaviorSubject(1);
  @Input() set zoom(value: number) {
    this.zoomChange$.next(value);
  }
  get zoom(): number {
    return this.zoomChange$.value;
  }

  @Input() textRendering = true;
  @Input() annotationsRendering = true;

  @Output() readonly contentLoad = new EventEmitter<void>();
  @Output() readonly layoutChange = new EventEmitter<PageRect[]>();

  @Output() readonly containerClick = new EventEmitter<void>();
  @Output() readonly acrofieldClick = new EventEmitter<AcrofieldClickEvent>();
  @Output() readonly acrofieldContextMenuClick = new EventEmitter<AcrofieldClickEvent>();

  @Output() readonly pdfClick = new EventEmitter<PdfAnchor>();
  @Output() readonly selectionChange: Observable<PdfAnchor | undefined>;

  @Output() readonly currentPage = new EventEmitter<number>();

  /**
   * DOM elements generated by Angular directives from the PDF.
   * It's an overlay on top of PDF Canvas and all
   */
  @ViewChildren('pageElement') pageElementRefs?: QueryList<ElementRef<HTMLDivElement>>;

  // Internals
  private selectionContainer: HTMLDivElement | null = null;
  private silenceSelection = true;
  private readonly sizeChange$ = new Subject<void>();

  readonly getAnchorFromAnnotation = getAnchorFromAnnotation;
  readonly isAnnotationSupported = isAnnotationSupported;
  readonly scrollToPage = scrollToPage;

  // Observables
  readonly selectionInfo$ = new BehaviorSubject<SelectionRangeInfo[] | null>(null);

  /**
   * @deprecated use `currentPage` output instead
   */
  private currentPage$?: Observable<number>;

  constructor(private readonly ngZone: NgZone) {
    this.selectionChange = this.selectionInfo$.pipe(
      switchMap(async (selection) => {
        if (!this.silenceSelection && this.data && selection) {
          const data = this.data;
          return new Promise<PdfAnchor>((resolve, reject) => {
            this.ngZone.runOutsideAngular(() => {
              getAnchorFromSelection(data, selection).then(resolve, reject);
            });
          });
        }

        return undefined;
      }),
    );
  }

  ngAfterViewInit(): void {
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    this.data?.getData().then(() => this.contentLoad.next());

    const pageRefs = this.pageElementRefs;
    required(pageRefs);

    // TODO: remove this as soon as possible, it should not be used at all
    this.currentPage$ = pageRefs.changes.pipe(switchMap((pages) => getCurrentPage(pages)));

    pageRefs.changes.pipe(
      switchMap((pages) => getCurrentPage(pages)),
      untilDestroyed(this),
    ).subscribe((current) => this.currentPage.next(current));

    combineLatest([
      pageRefs.changes,
      this.sizeChange$.pipe(startWith([undefined]), debounceTime(50)),
      this.zoomChange$,
    ]).pipe(
      waitAnimationFrame(),
      map(() => pageRefs.map((x) => ({
        // CHECKME: should we use offsetXXX or getBoundingClientRect?
        top: x.nativeElement.offsetTop,
        left: x.nativeElement.offsetLeft,
        width: x.nativeElement.offsetWidth,
        height: x.nativeElement.offsetHeight,
      }))),
      distinctUntilChanged(equal),
      untilDestroyed(this),
    ).subscribe((layout) => this.layoutChange.emit(layout));
  }

  @HostListener('window:resize')
  handleResize(): void {
    this.sizeChange$.next();
  }

  @HostListener('document:selectionchange')
  handleSelectionChange(): void {
    this.selectionInfo$.next(null);

    const selection = document.getSelection();

    if (!selection) {
      return;
    }
    if (!this.selectionContainer) {
      return;
    }

    const { selectionContainer } = this;
    let validRanges = createArray(selection.rangeCount, (i) => selection.getRangeAt(i))
      .filter((range) => !range.collapsed)
      .filter((range) => selectionContainer.contains(range.commonAncestorContainer));

    if (validRanges.length === 0) {
      return;
    }

    if (validRanges.length > 1) {
      const lastRange = validRanges.pop();
      const firstRange = validRanges[0];
      required(lastRange);
      firstRange.setEnd(lastRange.endContainer, lastRange.endOffset);
      validRanges = [firstRange];
    }

    const ranges = validRanges.map((range): SelectionRangeInfo => {
      const start = range.cloneRange();
      const end = range.cloneRange();

      return {
        start: getSelectionCaret(start, true),
        end: getSelectionCaret(end, false),
      };
    });

    this.selectionInfo$.next(ranges);
  }

  clickPoint(page: PDFPageProxy, element: HTMLDivElement, event: MouseEvent): void {
    const { pageNumber } = page;
    const anchor = pointerToAnchor(element, pageNumber, event);
    this.pdfClick.emit(anchor);
  }

  onSelectionStart(element: HTMLDivElement, _event: Event): void {
    this.selectionContainer = element;
    this.silenceSelection = true;
  }

  onSelectionEnd(): void {
    this.silenceSelection = false;
    this.handleSelectionChange();
  }

  /**
   * @deprecated use `currentPage` output instead
   */
  getCurrentPage(): Observable<number> | undefined {
    return this.currentPage$;
  }

  getPages = (pdf: PDFDocumentProxy): Promise<Array<PDFPageProxy>> => new Promise(async (resolve, reject) => {
    await this.ngZone.runOutsideAngular(() => getPages(pdf).then(resolve, reject));
  });

  getTextContent = (page: PDFPageProxy): Promise<TextContent> => new Promise(async (resolve, reject) => {
    await this.ngZone.runOutsideAngular(() => page.getTextContent().then(resolve, reject));
  });

  getAnnotations = (page: PDFPageProxy): Promise<any[]> => new Promise(async (resolve, reject) => {
    await this.ngZone.runOutsideAngular(() => page.getAnnotations().then(resolve, reject));
  });
}
